/* 
 * Copyright (c) 2018-2024 adorsys GmbH and Co. KG
 * All rights are reserved.
 */

pub mod enums;
use serde::{Deserialize, Serialize};
use chrono::NaiveDateTime;
use rust_decimal::Decimal;
use diesel::prelude::*;

// Pull in your Diesel table definitions (macro-generated by `diesel print-schema`)
use crate::schema::*;

// Pull in your custom enums (defined via diesel-derive-enum)
use crate::models::enums::{
    AccountCategory, BalanceSide, PostingStatus, PostingType, StmtStatus,
};

/// All accounts used by a company are defined in a chart of account.
//
// 1) chart_of_account
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = chart_of_account)]
#[diesel(primary_key(id))]
pub struct ChartOfAccount {
    pub id: String,
    pub created: NaiveDateTime,
    pub user_details: String,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = chart_of_account)]
pub struct NewChartOfAccount {
    pub id: String,
    pub created: NaiveDateTime,
    pub user_details: String,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,
    pub name: String,
}

/// The name property of a chart of account must be unique.
//
// 2) ledger
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = ledger)]
#[diesel(primary_key(id))]
pub struct Ledger {
    pub id: String,
    pub created: NaiveDateTime,
    pub user_details: String,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,
    pub name: String,
    pub coa_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = ledger)]
pub struct NewLedger {
    pub id: String,
    pub created: NaiveDateTime,
    pub user_details: String,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,
    pub name: String,
    pub coa_id: String,
}

/// An account is used to group related posting lines.
//
// 3) ledger_account
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = ledger_account)]
#[diesel(primary_key(id))]
pub struct LedgerAccount {
    pub id: String,
    pub created: NaiveDateTime,
    pub user_details: String,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,
    pub name: String,

    pub ledger_id: String,
    pub parent_id: Option<String>,

    /// The Chart of account defining this ledger account.
    ///
    /// This can be inherited from the parent account. Must always
    /// be the same as the parent chart of account if any.    
    pub coa_id: String,

    pub balance_side: BalanceSide,
    pub category: AccountCategory,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = ledger_account)]
pub struct NewLedgerAccount {
    pub id: String,
    pub created: NaiveDateTime,
    pub user_details: String,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,
    pub name: String,

    pub ledger_id: String,
    pub parent_id: Option<String>,
    pub coa_id: String,

    pub balance_side: BalanceSide,
    pub category: AccountCategory,
}

//
// 4) operation_details
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = operation_details)]
#[diesel(primary_key(id))]
pub struct OperationDetails {
    pub id: String,
    pub op_details: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = operation_details)]
pub struct NewOperationDetails {
    pub id: String,
    pub op_details: Option<String>,
}

/// The word posting is associated with the moment at which the recorded
/// operation is effective in the ledger. Therefore, we distinguish between
/// the following moments:
/// - The operation time: the moment at which this operation took place
/// - The posting time: the moment at which this operation is
///   effectively posted to the ledger (e.g. influencing an account balance)
/// - The recording time: the moment at which this operation is recorded in the
///   journal.
//
// 5) posting
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = posting)]
#[diesel(primary_key(id))]
pub struct Posting {
    pub id: String,

    // HashRecord
    pub antecedent_id: Option<String>,
    pub antecedent_hash: Option<String>,
    pub hash: Option<String>,
    pub hash_alg: Option<String>,

    // Additional fields
    /// The user (technically) recording this posting.
    pub record_user: String,
    /// The time of recording of this posting.
    pub record_time: NaiveDateTime,
    /// The unique identifier of this business operation. The operation
    /// identifier differs from the posting identifier in that it is not unique.
    /// The same operation can be repetitively posted if some conditions change.
    /// The operation identifier will always be the same for all the postings of
    /// an operation. Only one of them will be effective in the account statement
    /// at any given time.    
    pub opr_id: String,
    /// The time of occurrence of this operation. Set by the consuming module.
    pub opr_time: Option<NaiveDateTime>,
    /// The type of operation recorded here. The semantic of this information is
    /// determined by the consuming module.    
    pub opr_type: Option<String>,
    /// The source of the operation. For example, a payment order may result
    /// in multiple payments. Each payment will be an operation. This field
    /// is used to document the original payment ID.    
    pub opr_src: Option<String>,
    /// The time from which the posting is effective in the account statement.
    /// This differs from the recording time, because the posting time can be
    /// before or after the recording time.
    ///
    /// If the posting time is before the recording time, it may affect earlier
    /// postings or past balances, potentially generating new postings.
    ///
    /// The posting time of an adjustment operation at day closing is always the
    /// last second of that day—even if it’s posted earlier in the day, the closing
    /// time remains the last second of that day. In the case of an adjustment
    /// operation, the posting time and the operation time are identical.    
    pub pst_time: NaiveDateTime,
    /// Some postings are mechanical and do not influence an account's balance. 
    /// Depending on the product module's business logic, different types of 
    /// posting might be defined, so the journal can document all events 
    /// related to an account.
    ///
    /// For a mechanical posting, the same account and amounts appear on both 
    /// the debit and credit sides. Some account statements may choose not 
    /// to display mechanical postings in the user statement.    
    pub pst_type: PostingType,
    pub pst_status: PostingStatus,
    pub ledger_id: String,
    /// The date used to compute interests. This date may differ from the posting date
    /// and can lead to the generation of different types of balances.    
    pub val_time: Option<NaiveDateTime>,
    /// The id of the discarded posting. In case this posting discards another posting.
    pub discarded_id: Option<String>,
    /// The record time of the discarded posting
    pub discarded_time: Option<NaiveDateTime>,

    /// Details associated with this operation.
    pub opr_details_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = posting)]
pub struct NewPosting {
    pub id: String,

    pub antecedent_id: Option<String>,
    pub antecedent_hash: Option<String>,
    pub hash: Option<String>,
    pub hash_alg: Option<String>,

    pub record_user: String,
    pub record_time: NaiveDateTime,
    pub opr_id: String,
    pub opr_time: Option<NaiveDateTime>,
    pub opr_type: Option<String>,
    pub opr_src: Option<String>,
    pub pst_time: NaiveDateTime,
    pub pst_type: PostingType,
    pub pst_status: PostingStatus,
    pub ledger_id: String,
    pub val_time: Option<NaiveDateTime>,
    pub discarded_id: Option<String>,
    pub discarded_time: Option<NaiveDateTime>,

    pub opr_details_id: Option<String>,
}

/// A posting trace documents the inclusion of a posting in the creation of a statement.
/// 
/// For each statement posting, an operation can only be involved once.
//
// 6) posting_trace
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = posting_trace)]
#[diesel(primary_key(id))]
pub struct PostingTrace {
    pub id: String,
    pub tgt_pst_id: String,
    pub src_pst_id: String,
    pub src_pst_time: Option<NaiveDateTime>,
    pub src_opr_id: String,
    pub account_id: String,
    pub debit_amount: Decimal,
    pub credit_amount: Decimal,
    pub src_pst_hash: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = posting_trace)]
pub struct NewPostingTrace {
    pub id: String,
    pub tgt_pst_id: String,
    pub src_pst_id: String,
    pub src_pst_time: Option<NaiveDateTime>,
    pub src_opr_id: String,
    pub account_id: String,
    pub debit_amount: Decimal,
    pub credit_amount: Decimal,
    pub src_pst_hash: Option<String>,
}

/// Document the state of a ledger at the statement date.
/// 
/// It is a financial statement that will help draw time lines on ledgers.
///
/// A trial balance is also a financial statement on the balance sheet that is
/// not closed.
///
/// You can continuously modify trial balances by adding posting and recomputing
/// some balances.
///
/// No changes are allowed in a ledger when the ledger has closed with a
/// financial statement.
//
// 7) ledger_stmt
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = ledger_stmt)]
#[diesel(primary_key(id))]
pub struct LedgerStmt {
    pub id: String,
    pub posting_id: Option<String>,
    pub pst_time: NaiveDateTime,
    pub stmt_status: StmtStatus,
    pub latest_pst_id: Option<String>,
    pub stmt_seq_nbr: i32,

    // from BaseEntity
    pub created: Option<NaiveDateTime>,
    pub user_details: Option<String>,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,

    pub ledger_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = ledger_stmt)]
pub struct NewLedgerStmt {
    pub id: String,
    pub posting_id: Option<String>,
    pub pst_time: NaiveDateTime,
    pub stmt_status: StmtStatus,
    pub latest_pst_id: Option<String>,
    pub stmt_seq_nbr: i32,

    pub created: Option<NaiveDateTime>,
    pub user_details: Option<String>,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,

    pub ledger_id: String,
}

/// Document the state of an account at the statement date.
/// 
/// The id of a statement is generally identical to the id of the documenting posting.
//
// 8) account_stmt
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = account_stmt)]
#[diesel(primary_key(id))]
pub struct AccountStmt {
    pub id: String,
    pub posting_id: Option<String>,
    pub pst_time: NaiveDateTime,
    pub stmt_status: StmtStatus,
    pub latest_pst_id: Option<String>,
    pub stmt_seq_nbr: i32,

    // from BaseEntity
    pub created: Option<NaiveDateTime>,
    pub user_details: Option<String>,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,

    // custom fields
    pub account_id: String,
    pub youngest_pst_id: Option<String>,
    pub total_debit: Decimal,
    pub total_credit: Decimal,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = account_stmt)]
pub struct NewAccountStmt {
    pub id: String,
    pub posting_id: Option<String>,
    pub pst_time: NaiveDateTime,
    pub stmt_status: StmtStatus,
    pub latest_pst_id: Option<String>,
    pub stmt_seq_nbr: i32,

    pub created: Option<NaiveDateTime>,
    pub user_details: Option<String>,
    pub short_desc: Option<String>,
    pub long_desc: Option<String>,

    pub account_id: String,
    pub youngest_pst_id: Option<String>,
    pub total_debit: Decimal,
    pub total_credit: Decimal,
}

//
// 9) posting_line
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = posting_line)]
#[diesel(primary_key(id))]
pub struct PostingLine {
    pub id: String,
    /// The associated ledger account
    pub account_id: String,
    pub debit_amount: Decimal,
    pub credit_amount: Decimal,
    /// This is the JSON representation of the transaction as posted for the product module.
    pub details_id: Option<String>,
    /// This is the account delivered by this posting. This field is generally used
    /// to back up information associated with the posting if the account referenced
    /// is not present in the corresponding ledger.    
    pub src_account: Option<String>,
    /// The id of the last balanced posting line for this account.
    pub base_line: Option<String>,
    pub sub_opr_src_id: Option<String>,

    // denormalized from Posting
    /// The time of recording of this posting.
    pub record_time: NaiveDateTime,
    /// The unique identifier of this business operation.
    /// If two postings have the same operation id, the one with the youngest
    /// record time is considered effective.    
    pub opr_id: String,
    /// The source of the operation. For example, a payment order may result in many
    /// payments. Each payment will be an operation. This field documents the original
    /// payment ID.    
    pub opr_src: Option<String>,
    /// This is the time from which the posting is effective in this account statement.
    pub pst_time: NaiveDateTime,
    /// Some postings are mechanical and do not influence an account's balance.
    /// Depending on the product module's business logic, different types of postings
    /// might be defined so that the journal can document all events associated with an account.
    ///
    /// For a mechanical posting, the same account and amounts must appear on both the
    /// debit and credit sides. Some account statements will not display mechanical postings
    /// when generating the user statement.    
    pub pst_type: PostingType,
    pub pst_status: PostingStatus,
    pub hash: String,
    /// The record time of the discarded posting
    pub discarded_time: Option<NaiveDateTime>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = posting_line)]
pub struct NewPostingLine {
    pub id: String,
    pub account_id: String,
    pub debit_amount: Decimal,
    pub credit_amount: Decimal,
    pub details_id: Option<String>,
    pub src_account: Option<String>,
    pub base_line: Option<String>,
    pub sub_opr_src_id: Option<String>,

    pub record_time: NaiveDateTime,
    pub opr_id: String,
    pub opr_src: Option<String>,
    pub pst_time: NaiveDateTime,
    pub pst_type: PostingType,
    pub pst_status: PostingStatus,
    pub hash: String,
    pub discarded_time: Option<NaiveDateTime>,
}

//
// 10) op_note
//
#[derive(Debug, Clone, Serialize, Deserialize, Queryable, Identifiable)]
#[diesel(table_name = op_note)]
#[diesel(primary_key(id))]
pub struct OpNote {
    pub id: String,
    pub rec_id: String,
    /// This is the type of the note. A note can be a simple comment, a task, a reminder...
    pub note_type: Option<String>,
    /// This is the content of the note. Format might be dependent of the note type.
    pub content: Option<String>,
    /// Time of recording of this note.
    pub rec_time: NaiveDateTime,
    /// Prospective time of execution of this note.
    pub exec_time: Option<NaiveDateTime>,
    /// States if execution might occur before execution time.
    pub premature_exc: Option<bool>,
    /// States if repeated execution is allowed.
    pub repeated_exec: Option<bool>,
    /// Document the status of execution of this note.
    pub exec_status: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Insertable)]
#[diesel(table_name = op_note)]
pub struct NewOpNote {
    pub id: String,
    pub rec_id: String,
    pub note_type: Option<String>,
    pub content: Option<String>,
    pub rec_time: NaiveDateTime,
    pub exec_time: Option<NaiveDateTime>,
    pub premature_exc: Option<bool>,
    pub repeated_exec: Option<bool>,
    pub exec_status: Option<String>,
}
